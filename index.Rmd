---
title: "Foundations of R programming I"
author: "Shamit Soneji"
date: "12/10/2018"
output: rmarkdown::github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Why use R?

R is a programming environment with a focus on mathematics and statistics, but can be used for a variety of applications given the flexibility of the language. R is also free and available for all operating systems. Given the richness of the language and no cost to use it, bioinformaticians have adopted R as the platform for which which to develop packages to solve bioinformatics problems.

## Getting R

Point your browser to http://cran.r-project.org/ to download and install the latest version of R. For these tutorials we are also going o use [RStudio](http://www.rstudio.com/) which is an advanced environment for R which includes a window for an editor, console, and plotting window. You will see what this means later.

With respect to bioinformatics, the central repository for bioinformatics tools is [Bioconductor](http://www.bioconductor.org) where packages are deposited for easy installation.

Before we go on to these, we need to get to grips with the basics of the R language first.

## R- The basics

### 1- Vectors

The R language is relatively intuative. For example, making a string of numbers from 1 to 10:

```{r}
x <- c(1,2,3,4,5,6,7,8,9,10)
```
The "c" in the code above means "combine", therefore all the comma separated numbers between the parentheses are put together to create a `vector`.

To view the contents of the object you have just created, just type "x" and hit return:

```{r}
x
```

There is a much simpler way to create the same type of object:

```{r}
x <- 1:10
x
```
Much better. Using a comma will always do increments of 1, but is also bidirectional:

```{r}
y <- 5:-5
y
```
Another way of ceating a sequence of numbers is to use the `seq` function. To learn how this function works, issue the command `help(seq)`. In R you can get a manual for any function using the `help()` command. To generate a vector of numbers from 1 to 100 in steps of 10 we need:

```{r}
a <- seq(0,100,by=10)
a
```
***Exercise:*** Generate a vector called 'b' ranging from 3 to 987 where the length of the vector is 53 entries long.
Done? Check the length of the vector you have just made by issuing `length(b)`.

Now that we can make vectors we can start playing with them. for example:
```{r}
c <- 1:50
d <- 1/c
```
Lets plot the numbers contained in the object we called `d`:

```{r fig.width=7, fig.height=6}
plot(d)
```
Note the way the axes are labelled in the plot function.

***Exercise:*** Call `help(plot)` and read about the other options available. Produce the same plot as above, but this time as a line plot which is coloured red. Also, label the axes and give the plot a title.

We can also do basic calculations on vectors:

```{r}
mean(d) # calculate the mean of the vector
sd(d) # the standard deviation
```

### 2- Matricies

Matricies are the most common data format bioinformaticians work with (microarray data for example). Lets make one:

```{r}
m <- matrix(0,ncol=5,nrow=10)
m
```
This will create a matrix filled with zeros. To transpose the matrix we use `t()` (this will be important later)

```{r}
tposed.m <- t(m)
tposed.m
```
Lets make a matrix (and a vector) containing numbers so we can look at subsetting:
```{r}
v <- 1:10
m <- t(matrix(1:50,ncol=10,nrow=5))
m
```
We can access individual elements using square brackets `[]`. Here are some examples:

```{r}
v[c(7,1,5)] #access elements 7 1 and 5 of the vector
m[1,] # access the first row of the matrix
m[,3] # the 3rd column
m[8,2] # the value in the 8th row and 2nd column
m[3:7,4] # the 3rd to 7th row of the 4th columnÃŸ
```
We often have the need to collect vectors and assemble them into matricies. This can be done using the `rbind` (row) and `cbind` (column) function:

```{r}
v1 <- 1:10
v2 <- 101:110
rbound.mat <-rbind(v1,v2)
cbound.mat <- cbind(v1,v2)
rbound.mat
cbound.mat
```

### 3- Lists

Lists are a class of container which allow multiple objects to be stored in a single variable. For example:
```{r}
alpha <- LETTERS[1:8]
mat <- matrix(rnorm(40),nrow=8)
listex1  <- list(char=alpha,nums=mat)
```
Each element can now be accessed via `$`:
```{r}
listex1$char
listex1$nums
listex1$nums[1,] # the matrix within the list issubsetted as before
```
Another way of doing the above is:
```{r}
listex1[[1]] # note the double square brackets
listex1[[2]]
listex1[[2]][1,]
```

4- Reading and writing files
==========================
To analyse data in R, you have to get the data into R first (this helps a lot). R has some useful functions to do this, so now we can take our first look at some microarray data. Download this file (http://bone.bmc.lu.se/Public/Yeast_O2_Averaged.txt) and save it to your current working directory.

***Exercise:*** Open the file to see how it looks, and then call `help(read.delim)` and try to work out how the file you are looking at could be read into R.

This is how I would do it:

```{r}
yst.data <- read.delim("Yeast_O2_Averaged.txt",header=T,row.name=1,sep="\t")
colnames(yst.data) # view the column names
nrow(yst.data) # the number of rows in the dataset
ncol(yst.data) # number of columns
dim(yst.data) # number of rows and columns together
```

***Exercise:*** Using subsetting we learnt about earlier, split this table into two parts called `yst.1pc` and `yst.20pc` to separate the 1% and 20% data shown in the headings. When you have done this, write these two matricies out into two separate files. 

```{r}
yst.20pc <- as.matrix(yst.data[,8:14])
```

There is a nicer way of doing it using `grep`.

### 5- Flow control and Functions

This is where it starts to get more interesting. Now we have these two datasets loaded in memory, we can use them to learn about flow control and some basic mathematical functions. We are going to do a few things the "long way" so you get the idea of how flow control works, and then we'll look at some shortcuts.

Flow control is how multi-step processes are carried out. In the example below we print out the numbers 1 to 10:

```{r}
for(i in 1:10){
  print(i)
}
```
To translate this code, it simply says for every integer from 1 to 10, print this value to the screen.

***Exercises:*** 
- Using the example above, print the first 10 lines of `yst.1pc` in a `for` loop.
- Print every 2nd line of `yst.1pc` from lines 1 to 50.

An important point regarding `for` loops is that any processes/calculations occurring within the loop will stay in the loop. If data generated within a loop has to be retained, we need to create a container to "fill up" while the loop is being carried out.

```{r}
vec <- NULL
for(i in 1:10){
  vec <- c(vec,i*10)
}
```
The container `vec` is initialised outside the loop, and then populated by concatenating on to it after every iteration of the loop.

***Exercise:*** Initialise as many empty containers as needed, and for `yst.1pc`, calculate the mean and standard devation of each row, and store the results in the containers you made.

We will now take a look at *functions*. As an example, lets turn the code you wrote in the exercise above into a function.

```{r}

calc.mean.and.sd <- function(mat){
  
  mn <- NULL
  sdev <- NULL
  
  for(i in 1:nrow(mat)){  
      mn <- c(mn,mean(mat[i,]))
      sdev <- c(sdev,sd(mat[i,]))
    
  }
  res <- list(mn=mn,sdev=sdev)
  res # the last line in a function is what the function will return
}

```
By putting this code into a function we can now calculate the means and deviations of any matrix. For example, `yst.20pc` which we haven't done yet:

```{r}
yst.20pc.mn.sd <- calc.mean.and.sd(yst.20pc) 
```
This is clearly easier than writing `for` loops. This function can now be "banked" for use whenever its needed. Calculating row means and deviations can be done much faster.

### 6- Apply

'apply' is a commonly used function in R to speed up matrix calculation. For example, to calculates means of a matrix we can do this:

```{r}
yst.20.pc.row.mn <- apply(yst.20pc,1,mean) # means of rows
yst.20.pc.col.mn <- apply(yst.20pc,2,mean) # means of columns
```
The format for the function is therefore the matrix first, the direction in which you would like to apply the function in the 3rd argument.

 use `apply` to calculate row and column totals and deviations for a yeast dataset of your choosing.

Your own functions can also be used with `apply` when used as the 3rd argument. Example:

```{r}

example.func <- function(v){
  
  val <- (mean(v)*sd(v))/sum(v)
  val
}

ex.apply <- apply(yst.20pc,1,example.func)

```

### 7- Standardising data

The data has already been normalised, and we can see this by boxplotting the expression values.

```{r}
par(mar=c(10,5,5,5)) # this simply makes the gap at the bottom bigger so the labels fit
boxplot(yst.20pc,las=2) # las rotates the x-axis lables by 90 degrees
```

Looking at the y-axis we can see the data has a log expression range of about 2 to 14. We can be more precise by calling 'range'.

```{r}
range(yst.20pc)
```

For many operations (such as clustering) the data needs to be z-score normalised (scaled) first. When we scale data, each row of gene is standarised so that it's mean=0 and sd=1. Specifically for a gene `g` of the i-th row:

$$Z_i= \frac{g_i-\hat{g}}{\sigma_g}$$

which means for each row we subtract the mean of the row, and then divide by the sd of the row.

***Exercise:*** write a function called `zscore` which will take a single vector of values and scale them. When you have done this, `apply` this to the yeast data to scale all rows and call it `yst.zs`.
```{r, echo=FALSE}
zscore <- function(v){
  z <- (v-mean(v))/sd(v)
  z
  }

yst.zs <- apply(yst.20pc,1,zscore)

```

Now take a look at the first row of the normalised data. Call `nrow` on the matrix. Does it look right? 

```{r}
yst.zs <- t(apply(yst.20pc,1,zscore))
boxplot(yst.zs,las=2)
```

We can see now the data has been centralised around 0. This transformation is particularly useful when we want to cluster the data.
8- Clustering
====================

Clustering is one of the most common visualisation techniques for expression data. Here we will learn how to do some basic clustering and plotting. The first thing we need to do is take the yeast data and reduce it a little first using some commands you have already learnt. 

***Exercise:*** Plot a histogram of the expression values in the yeast data. Remove any row where the maximum value does not exceed a value of 7. When you have done this calculate the standard deviation of each row, and remove any gene where its sd is less than 0.5. Put the final reduced matrix into an object called `yst.20pc.filt`, and then zscore this data into an object called `yst.20pc.filt.z`. Hint: `apply` and `which` are your friends here.

***Bonus exercise!:*** If you are done with the above, make a function to filter data which takes a mean and sd as variables.

```{r}

max.ind <- which(apply(yst.20pc,1,max)<7)
sd.ind <-  which(apply(yst.20pc,1,sd)<0.5)

rem.ind <- intersect(max.ind,sd.ind)

yst.20pc.filt <- yst.20pc[-rem.ind,]
yst.20pc.filt.z <- t(apply(yst.20pc.filt,1,zscore))

```

Lets cluster. R has many ways to do this, an many packages have been written specifically for array data. We are not going to use these for now, but concentrate on the basic functions which underly the more specialised packages. For example, the `gplots` package uses the `hclust` function which is provided by R. So we will use `hclust` for now.

To use `hclust` we need to provide a distance matrix. This is done using the `dist` function:

```{r}
yst.dst <- dist(yst.20pc.filt.z)
```

The we cluster using `hclust`:

```{r}
yst.hc <- hclust(yst.dst)
```

Plot the dendrogram:

```{r}
plot(yst.hc)
```

We can see this is pretty much useless. It is far to compact and doesn't really tell us anything. What we would like is to make a heatmap, and to do this we need to retrieve some information created by `hclust`

Call `names` to see which information is available in the newly created object:

```{r}
names(yst.hc)
```

What we need here is the component called `order`. We can get this using the `$` assignment.

```{r}
yst.hc$order[1:20] #just the first 20! remove `[1:20]` for the full vector
```

We use this to reorder the z-scored matrix:

```{r}
yst.hc.data <- yst.20pc.filt.z[yst.hc$order,]
```

To make a heatmap of the data call `image`:

```{r}
image(yst.hc.data)
```
Ok, this doesn't look like it should! The matrix is the wrong way round, the colours aren't right, and there are no labels. The downside to R is that getting all this done takes time and knowledge of R's plotting capabilities. Thankfully people have already done this and put the code into pakages for people to download and use.

***Exercise:*** Install the `gplots` package.

To use the functions provided by gplots we have to load it first:

```{r}
library(gplots)
```

We can now use the `heatmap.2` function which `gplots` provides:
```{r}
heatmap.2(yst.20pc.filt.z,col=greenred(20),trace="none",dendrogram=c("row"),Colv=FALSE)
```

***Exercise:*** Look/play with this command to work out what each of these options are.

Clustering is pretty pointless if you can't define groups and get to the gene names. To do this we need to cut the dendrogram. We do this using the `cutree` function. For example, if we want 4 groups we do:

```{r}
yst.hc.4grp <- cutree(yst.hc,k=4)
```

This produces a vector showing which cluster each gene belongs to. If we are happy with this number of clusters we can make our lives a bit easier and put the data and the cluster assignments into the same object:

```{r}
yst.lst <- list(data=yst.20pc.filt.z,cluster=yst.hc.4grp)
```


We can now plot all the genes which belong to cluster number 1 for example:
```{r}
yst.c1 <- yst.lst$data[which(yst.lst$cluster==1),]
plot(yst.c1[1,],ty="l",ylim=range(yst.c1))
apply(yst.c1,1,lines)
```

***Exercise:*** Rewrite the code above into a function called `plot.cluster` so you can plot the genes of any given cluster.

We can now write a function to plot all the clusters at the same time:


```{r,echo=FALSE}

plot.cluster <- function(m,clus){
  
  m.c1 <- m$data[which(m$cluster==clus),]
  plot(m.c1[1,],ty="l",ylim=range(m.c1))
  apply(m.c1,1,lines)
}

```

```{r}
plot.all.clusters <- function(m){

 cls <- ceiling(sqrt(max(m$cluster)))
 rs <- ceiling(max(m$cluster)/cls)

 par(mfrow=c(rs,cls)) 

 for(i in 1:max(m$cluster)){
   plot.cluster(m,i)
 }
}

```

Now run it:

```{r}
plot.all.clusters(yst.lst)
```

This doesn't look good. The black lines cross each other frequently making the overal pattern hard to see.

***Exercise:*** Make two new functions based on the ones above which plot the clusters using boxplots instead of lines.

```{r}
plot.box.cluster <- function(m,clus){
  
  m.cl <- m$data[which(m$cluster==clus),]
  
  boxplot(m.cl,las=2)
}

plot.all.boxclusters <- function(m){

 cls <- ceiling(sqrt(max(m$cluster)))
 rs <- ceiling(max(m$cluster)/cls)

 par(mfrow=c(rs,cls)) 

 for(i in 1:max(m$cluster)){
   plot.box.cluster(m,i)
 }
}

plot.all.boxclusters(yst.lst)
```

Lets try a faster method for clustering called k-means. Here we need to specify up front how many clusters we are looking for.

```{r}

yst.km <- kmeans(yst.20pc.filt.z,9)
yst.km.lst <- list(data=yst.20pc.filt.z,cluster=yst.km$cluster)
plot.all.boxclusters(yst.km.lst)

```

We'll now learn about exporting figures from R. This can be done from Rstudio using the export function, but it is better not to use this. I will explian at a later date why, but this is how you code to output to a png file:

```{r}

png("Kmeans_boxplot.png",height=800,width=1000) #opens the file
plot.all.boxclusters(yst.km.lst) #makes the plot and pipes it to the file
dev.off() #closes the pipe and finalises the file

```


